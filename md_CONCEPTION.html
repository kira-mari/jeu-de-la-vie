<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Jeu de la Vie - Conway: Document de Conception - Jeu de la Vie</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Jeu de la Vie - Conway
   </div>
   <div id="projectbrief">Implémentation C++17 avec architecture POO</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Document de Conception - Jeu de la Vie</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md62"></a> </p>
<h1><a class="anchor" id="autotoc_md63"></a>
1. Diagramme de Classes (Mermaid)</h1>
<h2><a class="anchor" id="autotoc_md64"></a>
Hiérarchie des États de Cellules</h2>
<div class="fragment"><div class="line">classDiagram</div>
<div class="line">    class EtatCellule {</div>
<div class="line">        &lt;&lt;abstract&gt;&gt;</div>
<div class="line">        +estVivante() bool</div>
<div class="line">        +estObstacle() bool</div>
<div class="line">        +cloner() unique_ptr~EtatCellule~</div>
<div class="line">        +versChaine() string</div>
<div class="line">        +versEntier() int</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    class CelluleMorte {</div>
<div class="line">        +estVivante() bool</div>
<div class="line">        +estObstacle() bool</div>
<div class="line">        +cloner() unique_ptr~EtatCellule~</div>
<div class="line">        +versEntier() int</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    class CelluleVivante {</div>
<div class="line">        +estVivante() bool</div>
<div class="line">        +estObstacle() bool</div>
<div class="line">        +cloner() unique_ptr~EtatCellule~</div>
<div class="line">        +versEntier() int</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    class CelluleObstacle {</div>
<div class="line">        -vivante : bool</div>
<div class="line">        +estVivante() bool</div>
<div class="line">        +estObstacle() bool</div>
<div class="line">        +cloner() unique_ptr~EtatCellule~</div>
<div class="line">        +versEntier() int</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    EtatCellule &lt;|-- CelluleMorte</div>
<div class="line">    EtatCellule &lt;|-- CelluleVivante</div>
<div class="line">    EtatCellule &lt;|-- CelluleObstacle</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md65"></a>
Hiérarchie des Règles du Jeu</h2>
<div class="fragment"><div class="line">classDiagram</div>
<div class="line">    class RegleJeu {</div>
<div class="line">        &lt;&lt;abstract&gt;&gt;</div>
<div class="line">        +calculerNouvelEtat(grille, ligne, colonne) unique_ptr~EtatCellule~</div>
<div class="line">        #compterVoisinsVivants(grille, ligne, colonne) int</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    class RegleStandard {</div>
<div class="line">        +calculerNouvelEtat(grille, ligne, colonne) unique_ptr~EtatCellule~</div>
<div class="line">        #compterVoisinsVivants(grille, ligne, colonne) int</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    class RegleTorique {</div>
<div class="line">        +calculerNouvelEtat(grille, ligne, colonne) unique_ptr~EtatCellule~</div>
<div class="line">        #compterVoisinsVivants(grille, ligne, colonne) int</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    RegleJeu &lt;|-- RegleStandard : bordures fixes</div>
<div class="line">    RegleJeu &lt;|-- RegleTorique : grille bouclée</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md66"></a>
Architecture Principale</h2>
<div class="fragment"><div class="line">classDiagram</div>
<div class="line">    class Cellule {</div>
<div class="line">        -etat : unique_ptr~EtatCellule~</div>
<div class="line">        -ligne : int</div>
<div class="line">        -colonne : int</div>
<div class="line">        +Cellule(ligne, colonne, etatInitial)</div>
<div class="line">        +definirEtat(nouvelEtat)</div>
<div class="line">        +obtenirEtat() EtatCellule&amp;</div>
<div class="line">        +estVivante() bool</div>
<div class="line">        +estObstacle() bool</div>
<div class="line">        +obtenirLigne() int</div>
<div class="line">        +obtenirColonne() int</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    class Grille {</div>
<div class="line">        -cellules : vector~vector~Cellule~~</div>
<div class="line">        -nbLignes : int</div>
<div class="line">        -nbColonnes : int</div>
<div class="line">        -regle : shared_ptr~RegleJeu~</div>
<div class="line">        -grilleMemoire : unique_ptr~Grille~</div>
<div class="line">        -premiereIteration : bool</div>
<div class="line">        +Grille(lignes, colonnes, regleJeu)</div>
<div class="line">        +obtenirCellule(ligne, colonne) Cellule&amp;</div>
<div class="line">        +definirEtatCellule(ligne, colonne, etat)</div>
<div class="line">        +mettreAJour(parallele : bool)</div>
<div class="line">        +estStable() bool</div>
<div class="line">        +placerMotif(motif, ligne, colonne) bool</div>
<div class="line">        +definirRegle(nouvelleRegle)</div>
<div class="line">        -mettreAJourLignes(ligneDebut, ligneFin, nouvelleGrille)</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    class JeuDeLaVie {</div>
<div class="line">        -grille : unique_ptr~Grille~</div>
<div class="line">        -iteration : int</div>
<div class="line">        -iterationMax : int</div>
<div class="line">        -modeTorique : bool</div>
<div class="line">        -modeParallele : bool</div>
<div class="line">        -historique : vector~unique_ptr~Grille~~</div>
<div class="line">        +JeuDeLaVie(grilleInitiale, nbIterations, torique, parallele)</div>
<div class="line">        +executerIteration() bool</div>
<div class="line">        +revenirEnArriere() bool</div>
<div class="line">        +obtenirGrille() Grille&amp;</div>
<div class="line">        +obtenirIteration() int</div>
<div class="line">        +obtenirIterationMax() int</div>
<div class="line">        +definirIterationMax(max) void</div>
<div class="line">        +estModeTorique() bool</div>
<div class="line">        +estModeParallele() bool</div>
<div class="line">        +estTermine() bool</div>
<div class="line">        +reinitialiser(nouvelleGrille)</div>
<div class="line">        +definirModeTorique(actif)</div>
<div class="line">        +definirModeParallele(actif)</div>
<div class="line">        +definirEtatCellule(ligne, colonne, etat) void</div>
<div class="line">        +placerMotif(motif, ligne, colonne) bool</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    Cellule &quot;1&quot; o-- &quot;1&quot; EtatCellule : contient</div>
<div class="line">    Grille &quot;1&quot; o-- &quot;n*m&quot; Cellule : contient</div>
<div class="line">    Grille &quot;1&quot; o-- &quot;1&quot; RegleJeu : utilise</div>
<div class="line">    JeuDeLaVie &quot;1&quot; o-- &quot;1&quot; Grille : gère</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md67"></a>
Interfaces et Utilitaires</h2>
<div class="fragment"><div class="line">classDiagram</div>
<div class="line">    class GestionnaireFichier {</div>
<div class="line">        &lt;&lt;utility&gt;&gt;</div>
<div class="line">        +chargerGrille(cheminFichier, regle)$ unique_ptr~Grille~</div>
<div class="line">        +sauvegarderGrille(grille, cheminFichier)$ void</div>
<div class="line">        +creerDossierSortie(cheminFichier)$ string</div>
<div class="line">        +extraireNomFichier(chemin)$ string</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    class InterfaceSFML {</div>
<div class="line">        -fenetre : unique_ptr~RenderWindow~</div>
<div class="line">        -jeu : JeuDeLaVie&amp;</div>
<div class="line">        -tailleCellule : int</div>
<div class="line">        -enPause : bool</div>
<div class="line">        -delaiIteration : float</div>
<div class="line">        -horloge : Clock</div>
<div class="line">        -couleurVivante : Color</div>
<div class="line">        -couleurMorte : Color</div>
<div class="line">        -couleurObstacleMort : Color</div>
<div class="line">        -couleurObstacleVivant : Color</div>
<div class="line">        -couleurGrille : Color</div>
<div class="line">        -vue : sf::View</div>
<div class="line">        +InterfaceSFML(jeuRef, largeur, hauteur, titre)</div>
<div class="line">        +executer() void</div>
<div class="line">        +definirDelaiIteration(delai) void</div>
<div class="line">        +mettreAJourVue() void</div>
<div class="line">        -gererEvenements() void</div>
<div class="line">        -afficher() void</div>
<div class="line">        -dessinerGrille() void</div>
<div class="line">        -dessinerInformations() void</div>
<div class="line">        -gererPlacementMotif(touche) void</div>
<div class="line">        -calculerTailleCellule() void</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    class InterfaceQt {</div>
<div class="line">        -jeu : JeuDeLaVie&amp;</div>
<div class="line">        -centralWidget : QWidget*</div>
<div class="line">        -canvasWidget : QWidget*</div>
<div class="line">        -btnPlayPause : QPushButton*</div>
<div class="line">        -btnStep : QPushButton*</div>
<div class="line">        -btnStepBack : QPushButton*</div>
<div class="line">        -btnReset : QPushButton*</div>
<div class="line">        -sliderVitesse : QSlider*</div>
<div class="line">        -spinIterationMax : QSpinBox*</div>
<div class="line">        -chkTorique : QCheckBox*</div>
<div class="line">        -chkParallele : QCheckBox*</div>
<div class="line">        -cmbMotifs : QComboBox*</div>
<div class="line">        -timer : QTimer*</div>
<div class="line">        -enPause : bool</div>
<div class="line">        -delaiMs : int</div>
<div class="line">        -tailleCellule : int</div>
<div class="line">        -iterationMax : int</div>
<div class="line">        -drawMode : int</div>
<div class="line">        +InterfaceQt(jeuRef)</div>
<div class="line">        +executer() void</div>
<div class="line">        +canvasMouseEvent(x, y, buttons) void</div>
<div class="line">        +dessinerGrille(painter) void</div>
<div class="line">        -onPlayPause() void</div>
<div class="line">        -onStep() void</div>
<div class="line">        -onStepBack() void</div>
<div class="line">        -onReset() void</div>
<div class="line">        -onVitesseChanged(valeur) void</div>
<div class="line">        -onIterationMaxChanged(valeur) void</div>
<div class="line">        -onToriqueChanged(state) void</div>
<div class="line">        -onParalleleChanged(state) void</div>
<div class="line">        -onPlacerMotif() void</div>
<div class="line">        -onTimerTick() void</div>
<div class="line">        -initialiserWidgets() void</div>
<div class="line">        -initialiserLayout() void</div>
<div class="line">        -mettreAJourAffichage() void</div>
<div class="line">        -calculerTailleCellule() void</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    class GrilleWidget {</div>
<div class="line">        -parent : InterfaceQt*</div>
<div class="line">        +GrilleWidget(p, parentWidget)</div>
<div class="line">        #paintEvent(event) void</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    class ModeConsole {</div>
<div class="line">        -jeu : JeuDeLaVie&amp;</div>
<div class="line">        -dossierSortie : string</div>
<div class="line">        -afficherDansConsole : bool</div>
<div class="line">        +ModeConsole(jeuRef, dossierSortie, afficher)</div>
<div class="line">        +executer() void</div>
<div class="line">        -afficherGrille() void</div>
<div class="line">        -sauvegarderIteration(numeroIteration) void</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    class TestsUnitaires {</div>
<div class="line">        &lt;&lt;utility&gt;&gt;</div>
<div class="line">        +executerTousLesTests()$ bool</div>
<div class="line">        -testerReglesBase()$ bool</div>
<div class="line">        -testerBloc()$ bool</div>
<div class="line">        -testerClignotant()$ bool</div>
<div class="line">        -testerPlaneur()$ bool</div>
<div class="line">        -testerModeTorique()$ bool</div>
<div class="line">        -testerObstacles()$ bool</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    InterfaceSFML --&gt; JeuDeLaVie : utilise (SFML)</div>
<div class="line">    InterfaceQt --&gt; JeuDeLaVie : utilise (Qt)</div>
<div class="line">    InterfaceQt &quot;1&quot; o-- &quot;1&quot; GrilleWidget : contient</div>
<div class="line">    GrilleWidget --&gt; InterfaceQt : appelle dessinerGrille</div>
<div class="line">    ModeConsole --&gt; JeuDeLaVie : utilise</div>
<div class="line">    GestionnaireFichier --&gt; Grille : crée</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md68"></a>
2. Diagramme de Séquence (Mermaid)</h1>
<h2><a class="anchor" id="autotoc_md69"></a>
Exécution d'une itération</h2>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant U as Utilisateur</div>
<div class="line">    participant IG as InterfaceSFML</div>
<div class="line">    participant J as JeuDeLaVie</div>
<div class="line">    participant G as Grille</div>
<div class="line">    participant R as RegleJeu</div>
<div class="line">    participant C as Cellule</div>
<div class="line">    </div>
<div class="line">    U-&gt;&gt;IG: Appui ESPACE</div>
<div class="line">    IG-&gt;&gt;J: executerIteration()</div>
<div class="line">    J-&gt;&gt;G: mettreAJour(parallele)</div>
<div class="line">    </div>
<div class="line">    loop Pour chaque cellule</div>
<div class="line">        G-&gt;&gt;R: calculerNouvelEtat(grille, i, j)</div>
<div class="line">        R-&gt;&gt;R: compterVoisinsVivants()</div>
<div class="line">        R--&gt;&gt;G: nouvel état</div>
<div class="line">        G-&gt;&gt;C: definirEtat(nouvelEtat)</div>
<div class="line">    end</div>
<div class="line">    </div>
<div class="line">    G--&gt;&gt;J: mise à jour terminée</div>
<div class="line">    J--&gt;&gt;IG: true</div>
<div class="line">    IG-&gt;&gt;IG: afficher()</div>
<div class="line">    IG--&gt;&gt;U: écran mis à jour</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md70"></a>
Chargement d'un fichier</h2>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant M as main</div>
<div class="line">    participant GF as GestionnaireFichier</div>
<div class="line">    participant G as Grille</div>
<div class="line">    participant C as Cellule</div>
<div class="line">    participant E as EtatCellule</div>
<div class="line">    </div>
<div class="line">    M-&gt;&gt;GF: chargerGrille(fichier, regle)</div>
<div class="line">    GF-&gt;&gt;GF: ouvrir fichier</div>
<div class="line">    GF-&gt;&gt;GF: lire dimensions (n, m)</div>
<div class="line">    GF-&gt;&gt;G: new Grille(n, m, regle)</div>
<div class="line">    </div>
<div class="line">    loop Pour chaque ligne</div>
<div class="line">        loop Pour chaque colonne</div>
<div class="line">            GF-&gt;&gt;GF: lire valeur</div>
<div class="line">            GF-&gt;&gt;G: definirEtatCellule(i, j, etat)</div>
<div class="line">            G-&gt;&gt;C: obtenirCellule(i, j)</div>
<div class="line">            C-&gt;&gt;E: new CelluleVivante() / CelluleMorte()</div>
<div class="line">            E--&gt;&gt;C: état créé</div>
<div class="line">        end</div>
<div class="line">    end</div>
<div class="line">    </div>
<div class="line">    GF--&gt;&gt;M: unique_ptr~Grille~</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md71"></a>
Placement de motif interactif</h2>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant U as Utilisateur</div>
<div class="line">    participant IG as InterfaceGraphique</div>
<div class="line">    participant J as JeuDeLaVie</div>
<div class="line">    participant G as Grille</div>
<div class="line">    </div>
<div class="line">    U-&gt;&gt;IG: Appui touche &#39;G&#39; (planeur)</div>
<div class="line">    IG-&gt;&gt;IG: gererPlacementMotif(&#39;G&#39;)</div>
<div class="line">    IG-&gt;&gt;J: placerMotif(&quot;planeur&quot;, ligne, col)</div>
<div class="line">    J-&gt;&gt;G: placerMotif(&quot;planeur&quot;, ligne, col)</div>
<div class="line">    </div>
<div class="line">    loop Pour chaque position du motif</div>
<div class="line">        G-&gt;&gt;G: definirEtatCellule(i, j, CelluleVivante)</div>
<div class="line">    end</div>
<div class="line">    </div>
<div class="line">    G--&gt;&gt;J: true (succès)</div>
<div class="line">    J--&gt;&gt;IG: true</div>
<div class="line">    IG-&gt;&gt;IG: afficher message console</div>
<div class="line">    IG--&gt;&gt;U: &quot;Motif &#39;planeur&#39; placé&quot;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md72"></a>
Séquence : Dessin souris (SFML)</h2>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant U as Utilisateur</div>
<div class="line">    participant IG as InterfaceSFML</div>
<div class="line">    participant J as JeuDeLaVie</div>
<div class="line">    participant G as Grille</div>
<div class="line"> </div>
<div class="line">    U-&gt;&gt;IG: Clic souris (x,y)</div>
<div class="line">    IG-&gt;&gt;IG: mapPixelToCoords(x,y)</div>
<div class="line">    IG-&gt;&gt;J: definirEtatCellule(ligne, colonne, EtatCellule)</div>
<div class="line">    J-&gt;&gt;G: definirEtatCellule(ligne, colonne, etat)</div>
<div class="line">    G--&gt;&gt;J: OK</div>
<div class="line">    J--&gt;&gt;IG: OK</div>
<div class="line">    IG--&gt;&gt;U: affichage mis à jour</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md73"></a>
Interface Qt - Interaction utilisateur</h2>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant U as Utilisateur</div>
<div class="line">    participant IQ as InterfaceQt</div>
<div class="line">    participant T as QTimer</div>
<div class="line">    participant J as JeuDeLaVie</div>
<div class="line">    participant G as Grille</div>
<div class="line">    </div>
<div class="line">    U-&gt;&gt;IQ: Clic bouton &quot;Démarrer&quot;</div>
<div class="line">    IQ-&gt;&gt;IQ: onPlayPause()</div>
<div class="line">    IQ-&gt;&gt;T: start(delaiMs)</div>
<div class="line">    IQ-&gt;&gt;IQ: setText(&quot;⏸ Pause&quot;)</div>
<div class="line">    </div>
<div class="line">    loop Toutes les delaiMs millisecondes</div>
<div class="line">        T-&gt;&gt;IQ: timeout signal</div>
<div class="line">        IQ-&gt;&gt;IQ: onTimerTick()</div>
<div class="line">        </div>
<div class="line">        alt Itération max atteinte</div>
<div class="line">            IQ-&gt;&gt;T: stop()</div>
<div class="line">            IQ-&gt;&gt;IQ: setText(&quot;▶ Démarrer&quot;)</div>
<div class="line">            IQ--&gt;&gt;U: message console</div>
<div class="line">        else Continuer</div>
<div class="line">            IQ-&gt;&gt;IQ: onStep()</div>
<div class="line">            IQ-&gt;&gt;J: executerIteration()</div>
<div class="line">            J-&gt;&gt;G: mettreAJour(parallele)</div>
<div class="line">            G--&gt;&gt;J: mise à jour OK</div>
<div class="line">            J--&gt;&gt;IQ: true</div>
<div class="line">            IQ-&gt;&gt;IQ: mettreAJourAffichage()</div>
<div class="line">            IQ-&gt;&gt;IQ: canvasWidget-&gt;update()</div>
<div class="line">            IQ--&gt;&gt;U: affichage actualisé</div>
<div class="line">        end</div>
<div class="line">    end</div>
<div class="line">    </div>
<div class="line">    U-&gt;&gt;IQ: Clic bouton &quot;Pause&quot;</div>
<div class="line">    IQ-&gt;&gt;T: stop()</div>
<div class="line">    IQ-&gt;&gt;IQ: setText(&quot;▶ Démarrer&quot;)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md74"></a>
3. Diagramme d'Activité (Mermaid)</h1>
<h2><a class="anchor" id="autotoc_md75"></a>
Activité principale du programme</h2>
<div class="fragment"><div class="line">flowchart TD</div>
<div class="line">    Start([Début]) --&gt; Args[Analyser arguments CLI]</div>
<div class="line">    Args --&gt; Load[Charger fichier d&#39;entrée]</div>
<div class="line">    Load --&gt; Create[Créer grille et jeu]</div>
<div class="line">    Create --&gt; Mode{Mode ?}</div>
<div class="line">    </div>
<div class="line">    Mode --&gt;|Console| CreateConsole[Créer ModeConsole]</div>
<div class="line">    Mode --&gt;|SFML| CreateSFML[Créer InterfaceSFML]</div>
<div class="line">    Mode --&gt;|Qt| CreateQt[Créer InterfaceQt]</div>
<div class="line">    </div>
<div class="line">    CreateConsole --&gt; LoopConsole{Boucle: Tant que&lt;br/&gt;non terminé}</div>
<div class="line">    LoopConsole --&gt;|Continuer| ExecConsole[Exécuter itération]</div>
<div class="line">    ExecConsole --&gt; DisplayConsole[Afficher dans console]</div>
<div class="line">    DisplayConsole --&gt; SaveConsole[Sauvegarder fichier]</div>
<div class="line">    SaveConsole --&gt; LoopConsole</div>
<div class="line">    LoopConsole --&gt;|Terminé| End</div>
<div class="line">    </div>
<div class="line">    CreateSFML --&gt; LoopSFML{Boucle: Fenêtre&lt;br/&gt;ouverte ?}</div>
<div class="line">    LoopSFML --&gt;|Oui| EventsSFML[Gérer événements SFML]</div>
<div class="line">    EventsSFML --&gt; UpdateSFML{En pause ?}</div>
<div class="line">    UpdateSFML --&gt;|Non| IterSFML[Exécuter itération]</div>
<div class="line">    IterSFML --&gt; DrawSFML[Dessiner grille]</div>
<div class="line">    DrawSFML --&gt; LoopSFML</div>
<div class="line">    UpdateSFML --&gt;|Oui| DrawSFML</div>
<div class="line">    LoopSFML --&gt;|Fenêtre fermée| End</div>
<div class="line">    </div>
<div class="line">    CreateQt --&gt; LoopQt{Boucle: Application&lt;br/&gt;Qt active ?}</div>
<div class="line">    LoopQt --&gt;|Oui| EventsQt[Gérer événements Qt]</div>
<div class="line">    EventsQt --&gt; TimerQt{Timer actif ?}</div>
<div class="line">    TimerQt --&gt;|Oui| CheckMaxQt{Itération max&lt;br/&gt;atteinte ?}</div>
<div class="line">    CheckMaxQt --&gt;|Non| IterQt[Exécuter itération]</div>
<div class="line">    IterQt --&gt; UpdateQt[Mettre à jour widgets]</div>
<div class="line">    UpdateQt --&gt; LoopQt</div>
<div class="line">    CheckMaxQt --&gt;|Oui| StopQt[Arrêter timer]</div>
<div class="line">    StopQt --&gt; LoopQt</div>
<div class="line">    TimerQt --&gt;|Non| LoopQt</div>
<div class="line">    LoopQt --&gt;|Fermée| End([Fin])</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md76"></a>
Mise à jour de la grille avec parallélisation</h2>
<div class="fragment"><div class="line">flowchart TD</div>
<div class="line">    Start([Début mettreAJour]) --&gt; NewGrid[Créer nouvelle grille vide]</div>
<div class="line">    NewGrid --&gt; Parallel{Parallèle ?}</div>
<div class="line">    </div>
<div class="line">    Parallel --&gt;|Oui| CreateThreads[Créer N threads&lt;br/&gt;Diviser en lignes]</div>
<div class="line">    Parallel --&gt;|Non| Sequential[Pour chaque cellule i,j]</div>
<div class="line">    </div>
<div class="line">    CreateThreads --&gt; ThreadWork[Chaque thread:&lt;br/&gt;Traiter ses lignes]</div>
<div class="line">    ThreadWork --&gt; Compute1[Calculer nouvel état&lt;br/&gt;avec règle]</div>
<div class="line">    Compute1 --&gt; Wait[Attendre tous threads]</div>
<div class="line">    </div>
<div class="line">    Sequential --&gt; Compute2[Calculer nouvel état&lt;br/&gt;avec règle]</div>
<div class="line">    Compute2 --&gt; Set[Définir nouvel état]</div>
<div class="line">    Set --&gt; Next{Toutes cellules&lt;br/&gt;traitées ?}</div>
<div class="line">    Next --&gt;|Non| Sequential</div>
<div class="line">    Next --&gt;|Oui| Replace</div>
<div class="line">    </div>
<div class="line">    Wait --&gt; Replace[Remplacer ancienne grille&lt;br/&gt;par nouvelle]</div>
<div class="line">    Replace --&gt; End([Fin])</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md77"></a>
4. Patterns de Conception Utilisés</h1>
<h2><a class="anchor" id="autotoc_md78"></a>
Strategy Pattern</h2>
<ul>
<li><b><a class="el" href="classRegleJeu.html" title="Classe abstraite représentant les règles du jeu.">RegleJeu</a></b> avec ses implémentations (<a class="el" href="classRegleStandard.html" title="Implémentation des règles standard du jeu de la vie.">RegleStandard</a>, <a class="el" href="classRegleTorique.html" title="Implémentation des règles pour une grille torique (extension bonus)">RegleTorique</a>)</li>
<li>Permet de changer les règles du jeu dynamiquement</li>
<li>Utilisé dans <code><a class="el" href="classGrille.html" title="Classe représentant la grille du jeu de la vie.">Grille</a></code> pour sélectionner le mode torique ou non</li>
</ul>
<h2><a class="anchor" id="autotoc_md79"></a>
State Pattern</h2>
<ul>
<li><b><a class="el" href="classEtatCellule.html" title="Classe abstraite représentant l&#39;état d&#39;une cellule.">EtatCellule</a></b> avec ses états concrets (<a class="el" href="classCelluleMorte.html" title="Classe représentant une cellule morte.">CelluleMorte</a>, <a class="el" href="classCelluleVivante.html" title="Classe représentant une cellule vivante.">CelluleVivante</a>, <a class="el" href="classCelluleObstacle.html" title="Classe représentant une cellule obstacle (extension bonus) Les cellules obstacles ne changent jamais ...">CelluleObstacle</a>)</li>
<li>L'état d'une cellule détermine son comportement (vivante, morte, obstacle)</li>
<li>Transition d'état gérée par les règles du jeu</li>
<li><b><a class="el" href="classCelluleObstacle.html" title="Classe représentant une cellule obstacle (extension bonus) Les cellules obstacles ne changent jamais ...">CelluleObstacle</a></b> peut être vivant (orange) ou mort (rouge) et ne change jamais d'état pendant la simulation</li>
</ul>
<h2><a class="anchor" id="autotoc_md80"></a>
Template Method Pattern</h2>
<ul>
<li><b><a class="el" href="classRegleJeu.html#a609e1db8b39928850ad88ce636a7011d" title="Calcule le nouvel état d&#39;une cellule selon les règles du jeu.">RegleJeu::calculerNouvelEtat()</a></b> utilise <b>compterVoisinsVivants()</b></li>
<li>Chaque sous-classe implémente sa propre façon de compter les voisins</li>
<li><a class="el" href="classRegleTorique.html" title="Implémentation des règles pour une grille torique (extension bonus)">RegleTorique</a> compte les voisins avec grille bouclée</li>
</ul>
<h2><a class="anchor" id="autotoc_md81"></a>
Dependency Injection</h2>
<ul>
<li>Les règles sont injectées dans la <a class="el" href="classGrille.html" title="Classe représentant la grille du jeu de la vie.">Grille</a> via le constructeur</li>
<li>L'interface graphique reçoit une référence au <a class="el" href="classJeuDeLaVie.html" title="Classe principale orchestrant le jeu de la vie.">JeuDeLaVie</a></li>
<li>Facilite les tests et la flexibilité</li>
</ul>
<h2><a class="anchor" id="autotoc_md82"></a>
Observer Pattern (implicite via événements Qt)</h2>
<ul>
<li><a class="el" href="classInterfaceQt.html" title="Interface graphique moderne avec Qt.">InterfaceQt</a> utilise le système de signals/slots de Qt</li>
<li>Les boutons émettent des signaux connectés aux slots (onPlayPause, onStep, etc.)</li>
<li>QTimer émet timeout signal pour l'animation automatique</li>
</ul>
<h2><a class="anchor" id="autotoc_md83"></a>
MVC Pattern (Model-View-Controller)</h2>
<ul>
<li><b>Model</b> : <a class="el" href="classJeuDeLaVie.html" title="Classe principale orchestrant le jeu de la vie.">JeuDeLaVie</a>, <a class="el" href="classGrille.html" title="Classe représentant la grille du jeu de la vie.">Grille</a>, <a class="el" href="classCellule.html" title="Classe représentant une cellule dans le jeu de la vie.">Cellule</a> (logique métier)</li>
<li><b>View</b> : <a class="el" href="classInterfaceSFML.html" title="Interface graphique avec SFML pour le jeu de la vie.">InterfaceSFML</a> (SFML), <a class="el" href="classInterfaceQt.html" title="Interface graphique moderne avec Qt.">InterfaceQt</a>, <a class="el" href="classModeConsole.html" title="Mode console pour l&#39;exécution et la sauvegarde des itérations.">ModeConsole</a> (affichage)</li>
<li><b>Controller</b> : Gestion d'événements dans les interfaces</li>
</ul>
<h1><a class="anchor" id="autotoc_md84"></a>
5. Justification des Choix Techniques</h1>
<h2><a class="anchor" id="autotoc_md85"></a>
Utilisation de unique_ptr et shared_ptr</h2>
<ul>
<li><b>unique_ptr</b> pour la propriété exclusive :<ul>
<li><a class="el" href="classCellule.html" title="Classe représentant une cellule dans le jeu de la vie.">Cellule</a> possède son <a class="el" href="classEtatCellule.html" title="Classe abstraite représentant l&#39;état d&#39;une cellule.">EtatCellule</a></li>
<li><a class="el" href="classJeuDeLaVie.html" title="Classe principale orchestrant le jeu de la vie.">JeuDeLaVie</a> possède sa <a class="el" href="classGrille.html" title="Classe représentant la grille du jeu de la vie.">Grille</a></li>
<li>Historique stocke des grilles uniques</li>
</ul>
</li>
<li><b>shared_ptr</b> pour la propriété partagée :<ul>
<li>Plusieurs grilles peuvent partager une règle (<a class="el" href="classRegleJeu.html" title="Classe abstraite représentant les règles du jeu.">RegleJeu</a>)</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md86"></a>
Polymorphisme</h2>
<ul>
<li>Les états et règles utilisent le polymorphisme pour permettre l'extensibilité</li>
<li>Facilite l'ajout de nouveaux états (ex: CelluleEnCroissance) ou règles (ex: RegleHighLife)</li>
<li>Respect du principe Open/Closed (SOLID)</li>
</ul>
<h2><a class="anchor" id="autotoc_md87"></a>
Séparation GUI/Logique</h2>
<ul>
<li>La logique métier (<a class="el" href="classGrille.html" title="Classe représentant la grille du jeu de la vie.">Grille</a>, <a class="el" href="classCellule.html" title="Classe représentant une cellule dans le jeu de la vie.">Cellule</a>, Règles) est complètement indépendante de l'affichage</li>
<li>Facilite les tests unitaires</li>
<li>Permet d'avoir 3 interfaces différentes (Console, SFML, Qt) sans dupliquer la logique</li>
</ul>
<h2><a class="anchor" id="autotoc_md88"></a>
Multithreading optimisé</h2>
<ul>
<li>Utilisation de std::thread pour la parallélisation par lignes</li>
<li><b>Pas de mutex</b> : chaque thread travaille sur ses lignes exclusives</li>
<li>Division du travail équitable entre threads (mettreAJourLignes)</li>
<li>Gain de performance de ~15% sur grandes grilles (500x500+)</li>
</ul>
<h2><a class="anchor" id="autotoc_md89"></a>
Choix de Qt vs SFML</h2>
<ul>
<li><b>SFML</b> : Légère, rapide, idéale pour animation fluide et grandes grilles</li>
<li><b>Qt</b> : Interface professionnelle avec widgets natifs, contrôles riches</li>
<li>Compilation conditionnelle : le projet compile avec l'une, l'autre, ou les deux</li>
</ul>
<h1><a class="anchor" id="autotoc_md90"></a>
6. Complexité et Performance</h1>
<h2><a class="anchor" id="autotoc_md91"></a>
Complexité temporelle</h2>
<ul>
<li>Mise à jour séquentielle: <b>O(n × m)</b> où n×m est la taille de la grille</li>
<li>Mise à jour parallèle: <b>O((n × m) / p)</b> où p est le nombre de threads</li>
<li>Comptage des voisins: <b>O(1)</b> (toujours 8 voisins à vérifier)</li>
<li>Placement de motif: <b>O(k)</b> où k est la taille du motif</li>
</ul>
<h2><a class="anchor" id="autotoc_md92"></a>
Complexité spatiale</h2>
<ul>
<li>Stockage de la grille: <b>O(n × m)</b></li>
<li><a class="el" href="classGrille.html" title="Classe représentant la grille du jeu de la vie.">Grille</a> temporaire lors de la mise à jour: <b>O(n × m)</b></li>
<li>Historique (undo): <b>O(h × n × m)</b> où h est le nombre d'itérations sauvegardées</li>
</ul>
<h2><a class="anchor" id="autotoc_md93"></a>
Optimisations implémentées</h2>
<ul>
<li><b>Réservation de mémoire</b> avec reserve() pour éviter les réallocations</li>
<li><b>Parallélisation sans mutex</b> : division par lignes complètes</li>
<li><b>Move semantics</b> avec std::move() pour éviter les copies coûteuses</li>
<li><b>Taille de cellule adaptative</b> : ajustée automatiquement selon la taille de grille</li>
<li><b>Calcul exact de fenêtre</b> : pas d'espace noir inutile (SFML/Qt)</li>
</ul>
<h2><a class="anchor" id="autotoc_md94"></a>
Benchmark (grille 1000×1000, 100 itérations)</h2>
<ul>
<li>Mode séquentiel: ~2.5s</li>
<li>Mode parallèle (8 threads): ~2.2s <br  />
</li>
<li>Gain: **~15%** grâce à l'optimisation sans mutex </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
